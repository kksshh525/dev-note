![](http://image.yes24.com/Goods/11681152/800x0)

> 클린 코드를 읽고 정리한 내용입니다.



<!-- TOC -->

- [CleanCode](#cleancode)
    - [2장 의미있는 이름](#2장-의미있는-이름)
    - [3장 함수](#3장-함수)
    - [4장 주석](#4장-주석)
    - [5장 형식 맞추기](#5장-형식-맞추기)
    - [6장 객체와 자료 구조](#6장-객체와-자료-구조)
    - [7장 오류 처리](#7장-오류-처리)
    - [8장 경계](#8장-경계)

<!-- /TOC -->
# CleanCode

## 2장 의미있는 이름
- 의도를 분명히 밝혀라 

## 3장 함수 
- 작게 만들어라 42
- **함수는 한 가지를 해야 한다** 44
- 코드는 위에서 아래로 이야기 처럼 읽혀야 좋다. 46
- 길고 서술적인 이름이 > 짧고 어려운 이름 보다 좋다 49
- **함수에서 이상적인 인수 개수는 0, 그다음 1, 2,3, 4개 이상은 이유가 필요함** 50

함수에서 인수 1개를 넘기는 이유로 가장 흔한 경우 2가지 
1. 인수에 질문을 던지는 경우 `boolean fileExists("myFile")`
2. 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpen("myFile")` 은 Strin형을 반환

- **플래그 인수는 추하다** 52
- 함수 이름에 키워드를 추가하는 형식 - assertEquals() 보다 assertExpectedEqualsActual(expected, actual) 이 좋다.ㄱ
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야함 56
- try/catch 블록 뽑아내기 

```java
public void delete(Page page){
  try{
    deletePageAndAllReferences(page);
  }catch(Exception e){
    logError(e)
  }
}
```

```java
private void deletePageAndAllReferences(Page page) throws Exception {
  deletePage(page);
  registry.deleteReference(page.name);
  configKeys.deleteKey(page.name.makeKey());
}

private void logError(Exception e){
  logger.log(e.getMessage());
}
```

- 오류 코드 대신 예외를 사용 한다. (오류 코드는 재컴파일/재배치를 함) 60
- 소프트웨어 짜는 행위는 여느 글짓기와 비슷. 생각을 기록 한 후, 읽기 좋게 다듬, 초안을 수정하고 문장을 고치고, 문단을 정리 한다. 61


## 4장 주석
주석에 대한 진실/오해 
> 나쁜 코드에 주석을 달지 마라. 새로 짜라
> 주석은 오래될 수록 코드에서 멀어진다. (계속 유지/보수 하기 힘들기 때문에) 
> 진실은 한 곳에만 존재한다. 바로 코드다
- **코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.**
- 나쁜 주석: 대부분이 이 범주에 속함. 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화 하는 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. 
- 주석으로 처리한 코드 밉살스러운 관행 -> 소스 코드 관리 시스템 사용하므로 필요없다. 86


## 5장 형식 맞추기 
- 개념은 빈 행으로 분리하라 98
- 신문기사 처럼 작성하라 (위-> 아래, 첫 문단은 전체를 요약 ...)
- 세로 밀집도는 연관성을 의미한다. 100
- 변수는 사용하는 위치에 최대한 가까이 선언한다. 101
- 인스턴스 변수는 클래스 맨 처음에 선언한다. 103
- 한 함수가 다른 함수를 호출 한다면 두 함수는 세로로 가까이 배치한다. 104
- 개념적인 친화도가 높을 수록 코드를 가까이 배치한다. 106
- 개인적으로 120자 행 길이 정도
- 팀에 속한다면 자신이 선호할 규칙은 팀 규칙이다 113


## 6장 객체와 자료 구조
- 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.
- 새로운 자료 타입이 필요한 경우 -> 클래스와 객체 지향 기법이 가장 적합 122
- 새로운 자료 타입이 아닌, 함수가 필요한 경우 -> 절차적인 코드와 자료 구조가 좀 더 적합 122

## 7장 오류 처리 
- null을 반환하지 마라. 실상 null 확인이 너무 많아 문제다. API가 null을 반환 한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 139
- null을 전달하지 마라. 위의 경우 보다 더 나쁨

## 8장 경계 





## 10장 클래스

- 클래스는 작아야 한다. 
- 함수는 물리적으로 행 수의 크기를 측정했다. 클래스는 맡은 책임을 센다. 



단일 책임원칙

- 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나 뿐이어야 한다는 원칙이다.
- 소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨긋하게 만드는 활동은 완전히 별개다. 
- 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 
- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.



응집도 

- 클래스는 인스턴스 변수 수가 작아야 한다. 일반적으로 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메서드 마다 사용하는 클래스는 응집도가 가장 높다. 



