# JPA 요약

목차
- [1.JPA 소개]()
- [2.JPA 시작하기]()
- [3.영속성 관리]()
- [4.엔티티 매핑]()
- [5.연관관계 매핑 기초]()



## 1. JPA 소개 
- SQL을 직접 다룰 때 문제점
- 객체 지향 언어와 데이터베이스간의 패러다임 불일치 문제 발생
- JPA 가 해결



```
JPA는 같은 트랜잭션이 때 같은 객체가 조회되는 것을 보장
왜? 1차 캐쉬를 생각해봐!
```




## 2. JPA 시작하기

### 순수 자바 환경에서는

엔티티 매니저 팩토리를 직접만들어 엔티티 매니저를 생성한다.

- Persistence가 Spring의 application.properties 메타 정보를 읽는다. 
- Persistence.createEntityManagerFactory() 매니저 팩토리를 생성한다. 
- 매니저 팩토리는 EntityManager를 여러 개 만든다. 
- EntityManger가 CRUD의 기능을 한다. 

### Spring 프레임워크 에서는

컨테이너가 엔티티 매니저를 관리하고 제공한다. 

* `@PersistenceContext`  는 컨테이너가 관리하는 엔티티 매니저를 주입하는 어노테이션



> Insert, update, 단건 조회는 SQL이 필요없다.
> 하지만, 검색 쿼리에서 여러건들을 조회할 때는 특정 조건의 쿼리문이 필요하다. 
> 여기서 등장한게 JPQL이다. 
> - SQL 은 테이블을 다룬다.
> - JPQL 은 엔티티를 다룬다. 





## 3. 영속성 관리 

영속성 컨텍스트(Persistence Context) : **엔티티를 영구히 저장하는 환경**

### 엔티티 생명주기

![](https://www.objectdb.com/files/images/manual/jpa-states.png)

- 비영속: 영속성 컨텍스트와 전혀 관계 없는 상태
- 영속: 영속성 컨텍스트에 저장 된 상태
- 준영속 : 영속성 컨텍스트에 저장 되었다가, 분리된 상태
- 삭제: 삭제된 상태



### 조회 

영속 컨텍스트에서 관리한다. @Id 유니크한 키 값을 통해서 Map형태로 저장된다. 메모리 상(1차 캐쉬)에서 엔티티를 조회한다. 없으면 DB에서 조회한다. 

### 저장 

`persist(memberA)` 를 호출하면 1)영속성 컨텍스에 올라가고,  2)Insert 쿼리가 쓰기 지연 저장소에 올라간다. (아직 DB에 저장은 되지 않은 상태) 

트랜잭션을 커밋하는 순간(스프링에서 @Transactional 을 단 함수가 끝났을 때 )  DB에 flush를 한다. 

### 수정

영속성 상태에서 관리하는 엔티티인 경우에 변화에 감지한다. 실제 영속성 컨텍스트에서 엔티티 외에 snapshot이 떠져있다. `update(memberA)`  이런 함수가 존재하지 않는다. 

1. 트랜잭션 커밋이 일어나면 
2. 엔티티와 스냅샷을 비교하고
3. UPDATE SQL문을 쓰기 지연 저장소에 저장한다. 
4. flush()를 통해 DB에 업데이트를 한다.

> 원래는 name, age, grade 필드 중 name, age만 변경하면, 변경 필드만 update될 것 같지만 실제로는 전체 필드를 업데이트 하는 쿼리를 만든다. 해당 필드만을 원한다면 Hibernate로 확장 하면 된다.  `@DynamicUpdate` 


## 4.엔티티 매핑
- 객체와 테이블 매핑: `@Entity`, `@Table`
- 기본 키 매핑: `@Id`
- 필드와 컬럼 매핑: `@Column`
- 연관관계 매핑: `@ManyToOne`, `@JoinColumn`

기본키 생성전략은 Auto를 통해서 
필드와 컬럼매핑은 엔티티에 @Column을 통해서 명시해 주면 좋다. 특히 제약조건도 같이(그래야 개발자가 명시적으로 확인 가능)
연관관계 매핑도 굳이 `@JoinColumn`를 사용하지 않아도, 필드의 이름의 기본키를 매핑 해주지만 기왕이면 명시적으로 표시하는게 바람직함


## 5. 연관관계 매핑 기초
- 방향성: 객체에는 방향성이 존재, 테이블은 양방향
- 연관관계: 1:N,1:1 관계 생성
- 연관관계의 주인: 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야한다. 

```
- 연관관계의 주인은 외래키가 있는 곳
- 양방향 연관관계는 연관관계 편의 메소드를 통해서 작성
```




