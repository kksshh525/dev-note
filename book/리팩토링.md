

> 리팩토링을 읽고 정리한 내용입니다. 

![](http://image.yes24.com/Goods/7951038/800x0)



# 3. 코드의 구린내

## 중복코드 



## 장황한 메서드

- 이전에는 하위 루틴을 호출할 때 오버헤드 때문에 길게 했으나, 현대 객체 지향에서는 메서드 길이가 길수록 개발자의 머릿속에서 오버헤드가 일어난다. 
- 짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정의해야한다.
- 메서드에 매개변수와 임시변수가 많으면 메서드 추출을 실시하기 어렵다. 
  - 임시 변수를 메서드 호출로 전환 기법
  - 임시 변수를 메서드 체인으로 전환 기법
  - 길게 열거된 매개변수는 매개변수 세트를 객체로 전환 기법
  - 객체를 통째로 전달 기법
  - 메서드 객체로 전환 기법
- 조건문과 루프도 역시 메서드로 빼야 한다. 
  - 조건문 쪼개기 기법
  - 루프를 컬렉션 클로저 메서드로 전환을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시 하면 된다 

## 방대한 클래스

기능이 지나치게 많은 클래스에 엄청난 수의 인스턴스 변수가 들어 있다. (중복코드가 많다 )

- 클래스 추출
- 모듈 추출
- 하위 클래스 추출



## 과다한 매개변수

초보 시절, 필요한 모든 데이터는 매개변수를 사용해 전달하라고 배웠다.

- 객체의 등장으로 상황은 달라짐
- 필요한 데이터가 없을 때는 그것을 가져오도록 다른 객체에 요청하면 된다. 
- 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는게 아니라 그 모든 데이터를 가져올 메서드만 절달하면 된다. 



이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메서드로 전환 기법을 적용하면 된다. 



## 수정의 산발

- 개발자는 소프트웨어를 수정하기 쉽게 구성한다.
- 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다. 
- 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정도리 때 일어난다. 
  - 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 함. 

## 기능의 산재

- 기능의 산재는 수정의 산발과 비슷하지만 정반대다. 
- 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다. 
  - 메서드 이동과 필드 이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.
- 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때 새 클래스를 만들어야 한다. 
  - 클래스 내용 직접 삽입



수정의 산발: 한 클래스에서 여러 수정이 발생하는 문제 
기능의 산재: 하나의 수정으로 여러 클래스가 바뀌게 되는 문제

어느 것이든 수정과 클래스가 일대일 대응되게 깔끔하게 정리해야 한다. 



### 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로스세를 한 데 묶는 기술이라는 점이다. 

### 데이터 뭉치

데이터의 항목은 몰려다니는 습성이 있다. 두 클래스에 들어 있는 인스턴스 변수나 여러 메서드에 들어 있는 매개변수처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 둘 이상의 필드를 객체로 전화하면 코드가 개선된다.

### 강박적 기본 타입 사용

대개의 프로그랭 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화 할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 



### switch 문

객체 지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 이를 해결 할 수 있는 최상의 방법은 객체 지향 개념 중 하나인 **<u>다형성, 즉 재정의를 이용하는 것이다.</u>** 

### 평행 상속 계층

한 클래스의 하위클래스를 만들 때 마다 매번 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.



### 직무유기 클래스

하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼 기능을 수행하지 못하는 비효율적인 클래스는 없애야한다. 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 직무유기 클래스에 해당된다. 

### 막연한 범용 코드

### 임시 필드

