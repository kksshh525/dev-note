

> 리팩토링을 읽고 정리한 내용입니다. 

![](http://image.yes24.com/Goods/7951038/800x0)



# 3. 코드의 구린내

### 중복코드 



### 장황한 메서드

- 이전에는 하위 루틴을 호출할 때 오버헤드 때문에 길게 했으나, 현대 객체 지향에서는 메서드 길이가 길수록 개발자의 머릿속에서 오버헤드가 일어난다. 
- 짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정의해야한다.
- 메서드에 매개변수와 임시변수가 많으면 메서드 추출을 실시하기 어렵다. 
  - 임시 변수를 메서드 호출로 전환 기법
  - 임시 변수를 메서드 체인으로 전환 기법
  - 길게 열거된 매개변수는 매개변수 세트를 객체로 전환 기법
  - 객체를 통째로 전달 기법
  - 메서드 객체로 전환 기법
- 조건문과 루프도 역시 메서드로 빼야 한다. 
  - 조건문 쪼개기 기법
  - 루프를 컬렉션 클로저 메서드로 전환을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시 하면 된다 

### 방대한 클래스

기능이 지나치게 많은 클래스에 엄청난 수의 인스턴스 변수가 들어 있다. (중복코드가 많다 )

- 클래스 추출
- 모듈 추출
- 하위 클래스 추출



### 과다한 매개변수

초보 시절, 필요한 모든 데이터는 매개변수를 사용해 전달하라고 배웠다.

- 객체의 등장으로 상황은 달라짐
- 필요한 데이터가 없을 때는 그것을 가져오도록 다른 객체에 요청하면 된다. 
- 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는게 아니라 그 모든 데이터를 가져올 메서드만 절달하면 된다. 



이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메서드로 전환 기법을 적용하면 된다. 

### 수정의 산발

- 개발자는 소프트웨어를 수정하기 쉽게 구성한다.
- 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다. 
- 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정도리 때 일어난다. 
  - 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 함. 

### 기능의 산재

- 기능의 산재는 수정의 산발과 비슷하지만 정반대다. 
- 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다. 
  - 메서드 이동과 필드 이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.
- 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때 새 클래스를 만들어야 한다. 
  - 클래스 내용 직접 삽입

- 수정의 산발: 한 클래스에서 여러 수정이 발생하는 문제 
- 기능의 산재: 하나의 수정으로 여러 클래스가 바뀌게 되는 문제

어느 것이든 수정과 클래스가 일대일 대응되게 깔끔하게 정리해야 한다. 

### 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로스세를 한 데 묶는 기술이라는 점이다. 

### 데이터 뭉치

데이터의 항목은 몰려다니는 습성이 있다. 두 클래스에 들어 있는 인스턴스 변수나 여러 메서드에 들어 있는 매개변수처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 둘 이상의 필드를 객체로 전화하면 코드가 개선된다.

### 강박적 기본 타입 사용

대개의 프로그랭 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화 할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 

### switch 문

객체 지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 이를 해결 할 수 있는 최상의 방법은 객체 지향 개념 중 하나인 **<u>다형성, 즉 재정의를 이용하는 것이다.</u>** 

### 평행 상속 계층

한 클래스의 하위클래스를 만들 때 마다 매번 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.

### 직무유기 클래스

하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼 기능을 수행하지 못하는 비효율적인 클래스는 없애야한다. 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 직무유기 클래스에 해당된다. 

### 막연한 범용 코드

### 임시 필드

어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹있다. 이런 떠돌이 변수들이 서식할 집을 마련해 주려면 클래스 추출을 실시해야 한다. 그렇게 작성한 클래스에 그 변수들과 관련된 코드를 전부 넣어야 한다. 

### 메세지 체인

메세지 체인은 클라이언트가 한 객체에 제2의 객체를 요청하면, 제2의 객체가 제 3의 객체를 요청하고, 연쇄적 요청이 발생하는 문제점을 뜻한다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 상의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다. -> 대리 객체 은폐를 실시해야 한다. 

### 과잉 중개 메서드 

객체의 주요 특징 한가지는 바로 캡슐화다. 캘슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화는 대개 위임이 수반된다. 

### 지나친 관여

간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. 서로 지나치게 관여하는 클래스는 갈라놔야 한다. 

### 인터페이스가 다른 대용 클래스

기능은 같은데 시그니처가 다른 메서드에는 메서드명 변경을 실시해야 한다. 

### 미흡한 라이브러리 클래스

라이브러리 클래스에 넣어야할 메서드가 두개 뿐이라면 외래 클래스에 메서드 추가 기법을 실시하고, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기법을 실시하자. 

### 데이터 클래스

데이터 클래스는 필드와 필드 읽기/쓰 메서드만 들어 있는 클래스다. 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 

### 방치된 상속물

하위 클래스는 부모 클래스의 메서드와 데이터를 상속받는다. 그런데 상속받은 메서드나 데이터의 하위클래스에서 더 이상 쓰지 않거나 필요 없을 땐 어떻게 될까? 

1. 잘못된 계층 구조의 문제인 경우, 새 대등 클래스를 작성하고 메서드 하향과 필드 하향 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣어야 한다. 
2. 상속을 위임으로 전환 기법을 적용해서 계층구조를 없애야 한다.



### 불필요한 주석

엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많다. 

어떤 코드 구간의 기능을 설명할 주석이 필요할 때는 메서드 추출을 실시해야 한다. 메서드가 이미 추출된 상태임에도 기능을 설명할 주석이 필요하다면, 메서드명 변경을 실시해야 한다. 시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는 어설션 넣기 





## 테스트 작성





## 6. 메서드 정리

리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다. 

- 핵심적인 리팩토링 기법은 코드 뭉치를 별도의 메서드로 빼내는 **메서드 추출 기법** 
  - 지역변수 처리(임시변수)
    - **메서드 호출로 전환 기법**을 사용해서 임시 변수를 제거한다. 
      - 임시 변수가 여러 부분에 사용 될  때는 **임시 변수 분리**를 실시
    - 임시변수가 너무 얽혀 있어서 메서드 호출로 전환 할 수 없을 때, **메서드 객체로 전환 기법**
- **메서드 내용 직접 삽입**



- 매개변수로 대입하는 값이 있을 때는 **매개변수로의 값 대입 제거**

* 메서드를 잘게 쪼개면 동작 원리를 이해하기가 훨씬 쉽다. 간혹 알고리즘을 명료하게 개선할 수 있음을 알게된다. **알고리즘 전환 기법**





### 메서드 추출

메서드가 너무 길거나 코드의 주석을 달아야만 의도를 이해할 수 있을 때, 그 코드를 빼내어 별도의 메서드로 만든다. 

직관적인 이름이 좋은 이유는 

1. 메서드가 적절히 잘게 쪼개져 있으면 다른 메서드에서 쉽게 사용한다.
2. 상위 계층의 메서드에서 주석 같은 더 많은 정보를 읽어 들일 수 있다.
3. 재정의하기 훨씬 수월하다.

> 중요한 것은 메서드의 길이가 아니라 메서드명과 메서드 내용의 의미적 차이라고 할 수 있다. 메서드 추출로 코드의 명료성이 향상되기만 한다면, 메서드명이 추출한 코드 보다 길어도 메서드 추출을 실시해야 한다.



- 지역변수 문제 중 제일 가벼운 경우는 지역변수가 읽히기만 하고 변경되지 않을 때다. 이럴 땐 지역변수를 매개변수로 전달하면 된다.

### 메서드 내용 직접 삽입

