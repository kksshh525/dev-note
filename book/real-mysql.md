

## 5. 인덱스 

데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건이다. 

#### 5.1디스크 저장매체 

-   내장 디스크 → DAS → NAS → SAN 순으로 뒤로 갈수록 고사양 고성능이며, 구축 비용도 올라감 
    -   내장 디스크, DAS(Direct Attached storage)는 독자적으로 사용할 수 없고, 컴퓨터 본체에 연결해서만 사용할 수 있다.
    -   NAS는 TCP/IP를 통해 연결된다. 동시에 여러 컴퓨터에서 공유해서 사용할 수 있는 저장 매체이지만, SATA나 SAS 방식의 직접 연결보다는 속도가 매우 느리다. 
    -   SAN 은 DAS로 구축할 수 없는 아주 대용량의 스토리지 공간을 제공
        -   여러 컴퓨터에 동시에 사용할 수 있고, 본체와 광케이블로 연결하기 때문에 상당히 빠르고 안정적인 데이터 처리를 보장한다. 
-   SSD 는 기존의 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 대신 플래시 메모리를 장착하고 있다. 디스크 원판을 기계적으로 회전 시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다. 
    -   데이터베이스 서버에서는 순차 I/O 작업은 그다지 비중이 크지 않고, 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD 장점은 DBMS용 스토리지에 최적이다. 

#### 5.1.3 랜덤 I/O와 순차I/O

랜덤I/O라는 표현은 디스크 드라이브의 플래터(원판)을 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 



#### 5.2 인덱스란? 

책의 뒷페이지 색인과 DBMS 인덱스의 공통점은 바로 정렬이다. DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다. 

-   SortedList는 DBMS인덱스와 같은 자료구조 
    -   저장할때마다 항상 값을 정렬하므로, 과정이 복잡하고 느리다. 하지만 이미 정렬이 되어 있어서 찾을 때 굉장히 빠르다. 
-   ArrayList는 데이터 파일과 같은 자료구조



##### 데이터 저장방식(알고리즘 별)

-   B-Tree 인덱스: binary 가 아닌 balanced 이다. 
-   Hash 인덱스
-   Fractal- Tree 인덱스



#### 5.3 B-tree 인덱스

-   루트노드 - 최상위 노드
-   리프노드 - 트리 구조의 최하위 노드
-   브랜치 노드 - 루트랑 리프노드가 아닌 노드를



-   데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리된다. 
-   인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.
-   인덱스의 리프 노드는 데이터 파일에 저장된 레코드의 주소를 가지게 된다. 



#### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기 

##### 인덱스 레인지 스캔 

-   가장 대표적인 접근 방식, 빠른 방법
-   언제? 검색해야할 인덱스 범위가 결정됐을 때 사용하는 방식 
-   로트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 실제로 원하는 시작 지점을 찾을 수 있다.



##### 인덱스 풀 스캔 

-   인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식이다.
-   언제? 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
-   쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다. 





#### 5.3.5 다중컬럼 인덱스

실제 서비스용 데이터 베이스는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다. 인덱스의 두번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다는 것이다.





