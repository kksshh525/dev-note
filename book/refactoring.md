> 리팩토링을 읽고 정리한 내용입니다. 



# 3. 코드의 구린내

### 중복코드 



### 장황한 메서드

- 이전에는 하위 루틴을 호출할 때 오버헤드 때문에 길게 했으나, 현대 객체 지향에서는 메서드 길이가 길수록 개발자의 머릿속에서 오버헤드가 일어난다. 
- 짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정의해야한다.
- 메서드에 매개변수와 임시변수가 많으면 메서드 추출을 실시하기 어렵다. 
  - 임시 변수를 메서드 호출로 전환 기법
  - 임시 변수를 메서드 체인으로 전환 기법
  - 길게 열거된 매개변수는 매개변수 세트를 객체로 전환 기법
  - 객체를 통째로 전달 기법
  - 메서드 객체로 전환 기법
- 조건문과 루프도 역시 메서드로 빼야 한다. 
  - 조건문 쪼개기 기법
  - 루프를 컬렉션 클로저 메서드로 전환을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시 하면 된다 

### 방대한 클래스

기능이 지나치게 많은 클래스에 엄청난 수의 인스턴스 변수가 들어 있다. (중복코드가 많다 )

- 클래스 추출
- 모듈 추출
- 하위 클래스 추출



### 과다한 매개변수

초보 시절, 필요한 모든 데이터는 매개변수를 사용해 전달하라고 배웠다.

- 객체의 등장으로 상황은 달라짐
- 필요한 데이터가 없을 때는 그것을 가져오도록 다른 객체에 요청하면 된다. 
- 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는게 아니라 그 모든 데이터를 가져올 메서드만 절달하면 된다. 



이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메서드로 전환 기법을 적용하면 된다. 

### 수정의 산발

- 개발자는 소프트웨어를 수정하기 쉽게 구성한다.
- 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다. 
- 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정도리 때 일어난다. 
  - 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 함. 

### 기능의 산재

- 기능의 산재는 수정의 산발과 비슷하지만 정반대다. 
- 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다. 
  - 메서드 이동과 필드 이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.
- 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때 새 클래스를 만들어야 한다. 
  - 클래스 내용 직접 삽입

- 수정의 산발: 한 클래스에서 여러 수정이 발생하는 문제 
- 기능의 산재: 하나의 수정으로 여러 클래스가 바뀌게 되는 문제

어느 것이든 수정과 클래스가 일대일 대응되게 깔끔하게 정리해야 한다. 

### 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로스세를 한 데 묶는 기술이라는 점이다. 

### 데이터 뭉치

데이터의 항목은 몰려다니는 습성이 있다. 두 클래스에 들어 있는 인스턴스 변수나 여러 메서드에 들어 있는 매개변수처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 둘 이상의 필드를 객체로 전화하면 코드가 개선된다.

### 강박적 기본 타입 사용

대개의 프로그랭 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화 할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 

### switch 문

객체 지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 이를 해결 할 수 있는 최상의 방법은 객체 지향 개념 중 하나인 **<u>다형성, 즉 재정의를 이용하는 것이다.</u>** 

### 평행 상속 계층

한 클래스의 하위클래스를 만들 때 마다 매번 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.

### 직무유기 클래스

하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼 기능을 수행하지 못하는 비효율적인 클래스는 없애야한다. 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 직무유기 클래스에 해당된다. 

### 막연한 범용 코드

### 임시 필드

어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹있다. 이런 떠돌이 변수들이 서식할 집을 마련해 주려면 클래스 추출을 실시해야 한다. 그렇게 작성한 클래스에 그 변수들과 관련된 코드를 전부 넣어야 한다. 

### 메세지 체인

메세지 체인은 클라이언트가 한 객체에 제2의 객체를 요청하면, 제2의 객체가 제 3의 객체를 요청하고, 연쇄적 요청이 발생하는 문제점을 뜻한다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 상의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다. -> 대리 객체 은폐를 실시해야 한다. 

### 과잉 중개 메서드 

객체의 주요 특징 한가지는 바로 캡슐화다. 캘슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화는 대개 위임이 수반된다. 

### 지나친 관여

간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. 서로 지나치게 관여하는 클래스는 갈라놔야 한다. 

### 인터페이스가 다른 대용 클래스

기능은 같은데 시그니처가 다른 메서드에는 메서드명 변경을 실시해야 한다. 

### 미흡한 라이브러리 클래스

라이브러리 클래스에 넣어야할 메서드가 두개 뿐이라면 외래 클래스에 메서드 추가 기법을 실시하고, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기법을 실시하자. 

### 데이터 클래스

데이터 클래스는 필드와 필드 읽기/쓰 메서드만 들어 있는 클래스다. 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 

### 방치된 상속물

하위 클래스는 부모 클래스의 메서드와 데이터를 상속받는다. 그런데 상속받은 메서드나 데이터의 하위클래스에서 더 이상 쓰지 않거나 필요 없을 땐 어떻게 될까? 

1. 잘못된 계층 구조의 문제인 경우, 새 대등 클래스를 작성하고 메서드 하향과 필드 하향 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣어야 한다. 
2. 상속을 위임으로 전환 기법을 적용해서 계층구조를 없애야 한다.



### 불필요한 주석

엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많다. 

어떤 코드 구간의 기능을 설명할 주석이 필요할 때는 메서드 추출을 실시해야 한다. 메서드가 이미 추출된 상태임에도 기능을 설명할 주석이 필요하다면, 메서드명 변경을 실시해야 한다. 시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는 어설션 넣기 





## 테스트 작성





## 6. 메서드 정리

리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다. 

- 핵심적인 리팩토링 기법은 코드 뭉치를 별도의 메서드로 빼내는 **메서드 추출 기법** 
  - 지역변수 처리(임시변수)
    - **메서드 호출로 전환 기법**을 사용해서 임시 변수를 제거한다. 
      - 임시 변수가 여러 부분에 사용 될  때는 **임시 변수 분리**를 실시
    - 임시변수가 너무 얽혀 있어서 메서드 호출로 전환 할 수 없을 때, **메서드 객체로 전환 기법**
- **메서드 내용 직접 삽입**



- 매개변수로 대입하는 값이 있을 때는 **매개변수로의 값 대입 제거**

* 메서드를 잘게 쪼개면 동작 원리를 이해하기가 훨씬 쉽다. 간혹 알고리즘을 명료하게 개선할 수 있음을 알게된다. **알고리즘 전환 기법**





### 메서드 추출

메서드가 너무 길거나 코드의 주석을 달아야만 의도를 이해할 수 있을 때, 그 코드를 빼내어 별도의 메서드로 만든다. 

직관적인 이름이 좋은 이유는 

1. 메서드가 적절히 잘게 쪼개져 있으면 다른 메서드에서 쉽게 사용한다.
2. 상위 계층의 메서드에서 주석 같은 더 많은 정보를 읽어 들일 수 있다.
3. 재정의하기 훨씬 수월하다.

> 중요한 것은 메서드의 길이가 아니라 메서드명과 메서드 내용의 의미적 차이라고 할 수 있다. 메서드 추출로 코드의 명료성이 향상되기만 한다면, 메서드명이 추출한 코드 보다 길어도 메서드 추출을 실시해야 한다.



- 지역변수 문제 중 제일 가벼운 경우는 지역변수가 읽히기만 하고 변경되지 않을 때다. 이럴 땐 지역변수를 매개변수로 전달하면 된다.



### 메서드 내용 직접 삽입

*메서드 기능이 너무 단순해서 메서드명만 봐도 너무 뻔할 땐 그 메서드의 기능을 호출하는 메서드에 넣어버리고 그 메서드는 삭제하자*

### 임시 변수 내용 직접 삽입



### 임시변수를 메서드 호출로 전환

임시변수는 일시적이고 적용이 국소적 범위로 제한된다는 단점이 있다. 임시변수는 자신이 속한 메서드 안에서만 인식되므로, 그 임시변수에 접근하려다 보면 코드는 길어지게 마련이다. 임시변수를 메서드 호출로 수정하면 클래스 안 모든 메서드가 그 정보에 접근 할 수 있다. 이렇게 하면 클래스의 코드가 훨씬 깔끔해 진다. 

해당 경우는 메서드 추출을 적용하기 전에 반드시 적용해야 한다. 지역변수가 많을 수록 메서드 추출이 힘들어지므로 최대한 많은 변수를 메서드 호출로 고쳐야한다. 



#### 예제

```java
double getPrice(){
  int basePrice = _quantity * _itemPrice;
  double discountFaactor;
  
  if (basePrice > 1000){ 
    discountFactor = 0.95
  }else{
    discountFactor = 0.98
  }
 return basePrice * discountFactor;
}
```



```java
double getPrice(){
 return getPrice() * discountFactor();
}

int getPrice(){
   _quantity * _itemPrice
}

double discountFactor(){
  if (getPrice() > 1000){ 
    return 0.95
  }else{
    return = 0.98
  }
 
}
```



### 직관적 임시변수 사용

직관적 임시변수 사용은 조건문에서 각 조건 절을 가져와서 직관적 이름의 임시변수를 사용해 그 조건의 의미를 설명하려 할 때 많이 사용한다. 그 외에 긴 알고리즘에서 임시변수를 사용해서 계산의 각 단계를 설명할 수 있을 때 사용한다. 

**<u>직관적 임시변수 사용 기법을 적용해야겠다는 생각이 들더라도 될 수 있으면 그 기법을 적용하는 것을 자제하고 그 대신 메서드 추출을 사용하려고 노력한다</u>**

임시변수는 하나의 메서드 안에서만 사용할 수 있다. 메서드는 해당 객체의 전역뿐 아니라 다른 객체에도 사용할 수 있다. 

내가 메서드 추출 기법 사용을 선호하는 이유는 그 기법을 실시했을 때 이 메서드들을 객체의 다른 부분에서도 사용할 수 있기 때문이다. 

그럼 도대체 직관적 임시변수 사용 기법은 언제 사용하나? 

당연히 메서드 추출 기법 적용이 더 어렵거나 복잡할 때 사용한다. 알고리즘에 수많은 지역변수가 사용될땐 대체로 메서드 추출을 쉽게 적용할 수 없다. 로직의 복잡함이 덜해지면 나중에 언제든 임시변수를 메서드 호출로 전환 기법을 적용하면 될 일이다. 



### 임시변수 분리

임시변수의 용도는 다양한데, 일부 용도로 사용하다 보면 임시변수에 값이 여러 번 대입될 때가 있다. 여러 용도로 사용되는 변수는 각 용도 별로 다른 변수를 사용하게 분리해야 한다. 



### 매개변수로의 값 대입 제거???

*매개변수로 값을 대입하는 코드가 있을 땐 매개변수 대신 임시변수를 사용하게 수정하자*

매개변수로의 값대입이란? 어떤 메서드에 foo객체를 매개변수로 전달하면 '매개변수로의 값 대입'은 foo의 값을 다른 객체 참조로 변경한다는 의미다. 매개변수로 전달받은 객체에 어떠한 처리를 하든 상관 없고 일상적인 작업이지만, foo의 값을 다른 객체 참조로 변경하는 것은 절대로 안된다. 

```java
void aMethod(Object foo){
  foo.modify(); // 괜찮다.
  foo = anotherObject; // 고통과 절망을 안겨준다. 
}
```

자바에서 매개변수에 값을 대입해서는 안되고, 그런 코드를 보게 된다면 매개변수로의 값대입 제거를 적용해야 한다. 



### 메서드를 메서드 객체로 전환

*지역변수 때문에 메서드 추출을 적용할 수 없는 긴 메서드가 있을때 그 메서드 자체를 객체로 전환해서 모든 지역변수를 객체의 필드로 만들자. 그런 다음 그 메서드를 객체 안의 여러 메서드로 쪼개면 된다.*

이책의 핵심은 간결한 메서드의 아름다움. 장황한 메서드에서 각 부분을 간결한 메서드로 빼내면 코드가 훨씬 이해하기 쉬워진다. 메서드 분해를 어렵게 만드는 건 지역변수다. 

```java
Class Account {
  int gamma (int inputVal, int quantity, int yearToDate){
    int importantValue1 = (inputVal * quantity) + delta();
    int importantValue2 = (inputVal * yearToDate) + 100;
    if ( (yearToDate - importantValue1)> 100 )
      importantValue2 -= 20;
    int importantValue3 = importantValue2 * 7;
    //기타 작업
    return importantValue3 - 2 * importantValue;
  }
}
```



```java
Class Gamma {
  private final Account _account;
  private int inputVal;
  private int quantity;
  private int yearToDate;
  
  Gamma(int inputVal, int quantity, int yearToDate){
    this.inputVal = inputVal;
    this.quantity = quantity;
    this.yearToDate = yearToDate; 
  }
  
  public int compute(){
		int importantValue1 = (inputVal * quantity) + _account.delta();
    int importantValue2 = (inputVal * yearToDate) + 100;

    importantThing(); // 메서드 추출
    int importantValue3 = importantValue2 * 7;
    //기타 작업
    return importantValue3 - 2 * importantValue;
}

  void importantThing(){
    if ( (yearToDate - importantValue1)> 100 )
      importantValue2 -= 20;
  }

Class Account {
  int gamma(int inputVal, int quantity, int yearToDate){
    return new Gamma(inputVal, quantity, yearToDate).compute();
  }
}
```



### 알고리즘 전환

*알고리즘을 더 분명한 것으로 교체해야 할 땐 해당 메서드의 내용을 새 알고리즘으로 바꾸자*

어떤 작업을 약간 다르게 처리해야 해서 알고리즘을 변경해야 할 때도 있는데, 이럴 때는 좀 더 변경하기 쉬운 알고리즘으로 교체하는 것이 간편하다. 이렇게 하려면 메서드를 최대한 잘게 쪼개야 한다. []()



## 7장. 객체간의 기능 이동

### 메서드 이동

*메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 땐, 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드를 작성하자.*



### 클래스추출(<-> 클래스 추출)

- 두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐, 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자. 

### 

### 대리 객체 은폐(<-> 과잉 중개 메서드 제거)

- 객체의 핵심 개념중 하나는 캡슐화: 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것을 뜻함
  
  - 캡슐화를 통해서 무언가를 변경할때 그 변화를 전달해야 할 객체가 줄어들므로 변경하기 쉬워진다. 
- ### 



### 외래 클래스에 메서드 추가

- 사용중인 서버 클래스에 메서드 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성하자. 
- 코드 저작권이 문제라면 외래 메서드를 서버 클래스 제작자에게 보내서 직접 구현해 달라고 요청🐤



#### 국소적 상속확장 클래스 사용

- 사용중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐, 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성하자. 이 상속확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자. 



## 8. 데이터 체계화

- 데이터 연동을 더 간편하게 해준다. 



### 필드 자체 캡슐화

- 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐, 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만들자. 



### 데이터 값을 객체로 전환

- 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만들자. 



### 값을 참조로 전환

- 클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자. 





### 컬렉션 캡슐화

- 메서드가 컬렉션을 반환할 땐 그 메서드가 읽기전용 뷰를 반환하게 수정하고 추가 메서드와 삭제 메서드를 작성하자. 



### 레코드를 데이터 클래스로 전환

- 전통적인 프로그래밍 환경에서 레코드 구조를 이용한 인터페이스를 제공해야 할 땐 레코드 구조를 저장할 덤 데이터 객체를 작성하자



### 분류 부호를 클래스로 전환

- 기능에 영향을 미치는 숫자형 분류부호가 든 클래스가 있을 땐 그 숫자를 새 클래스로 바꾸자. 





## 9장 조건문 간결화 

### 조건문 쪼개기

- 복잡핞 조건문이 있을 땐, if, then, else 부분을 각각 메서드로 빼내자 
- 프로그램에서 가장 복잡한 부분은 주로 복잡한 조건문이다. 
  - 긴 코드가 그렇듯, 큰 덩어리의 코드를 잘게 쪼개고 각 코드 조각을 용도에 맞는 이름의 메서드 호출로 바꾸면 코드의 용도가 분명히 드러난다. 



### 중복 조건식 통합

- 여러 조건 검사식의 결과가 같을 땐, 하나의 조건문으로 합친후 메서드로 빼내자
- 서로 다른 여러개의 조건 검사식이 있는데 조건에 따른 결과가 모두 같을 때가 간혹 있다. 이럴 때는 논리 연산자 AND | OR를 사용해서 여러 조건 검사를 하나로 합쳐야 한다. 
- 합쳐야 하는 이유 ?
  - 첫째, 조건식을 합치면 여러 검사를 OR 연산자로 연결해서 실제로 하나의 검사 수행을 표현해서 무엇을 검사하는지 더 확실히 이해 할 수 있다. 조건을 나열해도 결과는 같지만, 그렇게 하면 한꺼번에 이뤄져야 할 각각의 검사가 불필요하게 따로 실행되는 것처럼 보인다.
  - 둘째, 조건식 통합 리팩토링 기법을 실시하면 메서드 추출을 적용할 수 있는 기반이 마련된다. 
    - 조건식을 메서드로 추출하면 처리중인 기능의 상태를 표현하던 코드가 기능 수행 목적을 표현하는 코드로 바뀐다.
- 조건식 안의 루틴이 단순히 조건을 검사해서 값을 반환할 땐 다음과 같이 삼항 연산자를 사용해서 그 루틴을 한 줄의 return 문으로 만들자. 

```java
if (onVacation() && lengthOfService() > 10 ) return 1;
else return 0.5;
```



```java
return ( onVacation() && lengthOfService() >10) ? 1: 0.5;
```



### 조건문의 공통 실행 코드 빼내기

- 조건문의 모든 절에 같은 실행 코드가 있을 땐, 같은 부분을 조건문 밖으로 빼자.
  - 그래야 각 절이 공통적으로 실행할 기능과 서로 다르게 실행할 기능을 한눈에 알 수 있다.
- 예외처리에도 이 방식을 적용할 수 있다. 코드가 try 구간과 모든 catch 구간 안의 예외발생 명령 뒤에 공통적으로 들어 있으면, 그 코드를 final구간으로 옮기면 된다.



### 제어 플래그 제거

- 논리 연산식의 제어 플래그 역할을 하는 변수가 있을 땐 그 변수를 break문이나 return 문으로 바꾸자.
- 제어 플래그는 유용함을 능가하는 단점이 있다.
  - 진입점과 이탈점이 하나씩 있는 루틴을 호출하는 구조적 프로그래밍의 문법적 잔재다. 
  - 그래서 프로그래밍 언어엔 복잡한 조건문을 방지하는 break문과 continue문이 있다. 



### 여러 겹의 조건문을 감시 절로 전환

- 메서드에 조건문이 있어서 정상적인 실행 경로를 파악하기 힘들 땐 모든 특수한 경우에 감시절을 사용하자. 
- 조건문은 주로 두가지 형태를 띤다.
  - 어느 한 경로가 정상적인 동작의 일부인지 검사하는 형태다.
  - 조건식 판별의 한 결과만 정상적인 동작을 나타내고 나머지는 비 정상적인 동작을 나타내는 형태다.
- 만약 둘다 정상 동작의 일부분이라면 if절과 else절로 구성된 조건문을 사용하고, 조건문이 특이한 조건이라면 그 조건을 검사해서 조건이 true일 경우 반환하자. 이런식의 검사를 감시절이라고 한다.



### 조건문을 재정의로 전환

- 객체 타입에 따라 다른 기능을 실행하는 조건문이 있을 땐 조건문의 각 절을 하위클래스의 재정의 메서드 안으로 옮기고, 원본 메서드는 abstract 타입으로 수정하자. 
- 재정의 본질은 타입에 따라 기능이 달라지는 여러 객체가 있을 때 일일이 조건문을 작성하지 않아도 다형적으로 호출되게 할 수 있다는 것이다.

### Null 검사를 널 객체에 위임

- null 값을 검사하는 코드가 계속 나올 땐 null값을 널 객체로 만들자. 
- 재정의 보질은 어떤 종류인지를객체에 일일이 물어서 그 응다벵 따라 실행할 기능을 호출하는 것이 아니라, 묻지도 따지지도 않고 기능을 곧바로 호출하는 것이다. 



### 어설션 넣기

- 일부 코드가 프로그램의 어떤 상태를 전제할땐, 어설션을 넣어서 그 전제를 확실하게 코드를 작성하자. 
- 특정 조건이 참일때만 코드의 일부분이 실행되는 경우가 많다. 
  - 이런 전제는 어설션을 넣어 명확히 드러나게 하는 것이 좋다.
- 어설션이란 항상 참으로 전제되는 조건문을 뜻한다. 
  - 어설션이 실패하면 그건 프로그래머가 오류를 범한 것
  - 실패할 경우 반드시 예외를 통지하게 해야 한다. 
  - 대게 제품화 단계에서 삭제한다. 
- 어설션의 장점은 코드 원리와 전제를 파악하기 쉽게 해준다는 점



## 10장 메서드 호출 단순화

- 이해와 사용이 쉬운 인터페이스를 작성하는 기술이야 말로 좋은 객체 지향 소프트웨어 개발에 꼭 필요하다.
- 이 장에서는 인터페이스를 더 쉽게 만드는 리팩토링 기법에 대해서 설명한다.
  - 가장 중요한 것은 메서드명을 변경하는 것
  - 매개변수 자체는 인터페이스를 다루는 데 상당한 역할을 한다. 
    - 병렬프로그래밍의 저자 '더글러스 리'는 매개변수 세트를 짧게 만드는 리팩토링에 대해서 경고함. 일반적으로 내장 객체나 값객체 같은 변경 불가 매개변수를 전달할 수 있게 하기 위해서다. 
- 좋은 인터페이스는 보여줘야 할 만큼만 딱 보여준다. 

### 메서드명 변경

- 메서드명을 봐도 기능을 알 수 없을 땐 메서드명을 직관적인 이름으로 바꾸자. 
- 코드는 컴퓨터보다 인간이 알아보기 쉽게 작성해야 한다.
- 매개변수를 재정렬해서 코드를 알아보기 쉬워진다면 매개변수 재정렬을 실시하자. 
  - 매개변수 추가 !
  - 매개변수 제거 !

### 매개변수 추가

- 메서드가 자신을 호출한 부분의 정보를 더 많이 알아야 할 땐 객체에 그 정보를 전달할 수 있는 매개변수를 추가하자. 
- 매개변수 추가는 부담없이 하면서도 매개변수 삭제는 꺼린다. 

### 상태 변경 메서드와 값 반환 메서드를 분리 

- 값 반환 기능과 객체 상태 변경 기능이 한 메서드에 들어 있을땐 질의 메서드와 변경메서드로 분리하자. 
- 값을 반환하며 눈에 띄는 부작용이 없는 함수를 작성했다면 그 함수는 높은 가치가 있다. 그런 함수는 필요할 때마다 몇 번이든 호출 할 수 있다.
- 값을 반환하는 모든 메서드는 눈에 띄는 부작용이 없어야 한다는 규칙을 따르는 것이 좋다. 
- 눈에띄는 부작용은 흔히 사용되는 최적화 방법은 반복되는 호출 성능을 개선하고자 필드에 들어 있는 반환 값을 캐시에 저장하는 방식이다. 이렇게 하면 객체의 상태가 캐시를 통해 볍ㄴ경되지만, 그 변경사항이 눈에 띄지 않는다. 



### 메서드를 매개변수로 전환

- 여러 메서드가 기능은 비슷하고 안에 든 값만 다를 땐 서로 다른 값을 하나의 매개변수로 전달받는 메서드를 하나 작성하자. 

### 매개변수를 메서드로 전환

- 매개변수로 전달된 값에 따라 메서드가 다른 코드를 실행할 땐 그 매개변수로 전달될 수 있는 모든 값에 대응하는 메서드를 각각 작성하자. 
- 일반적으로 한 매개변수의 값이 여러 개가 될 수 있을 때 조건문안에서 각 값을 검사하여 다른 기능을 수행하는 메서드에 적용하게 된다. 호출하는 부분은 매개변수에 값을 지정하여 무엇을 수행할지 판단해야 하므로, 여러 메서드를 작성하고 조건문을 없애는 것이 좋다. 

### 객체를 통째로 전달 ( 적용 예졔: EmailTemplateService.java )

- 객체에서 가져온 여러 값을 메서드 호출에서 매개변수로 전달할 땐 그 객체를 통째로 전달하게 수정하자.
- 객체가 한 객체에 든 여러 값을 메서드 호출할 때 매개변수로 전달하고 있다면 이 리팩토링 기법을 적용해야 한다.
- 호출된 객체가 나중에 새 데이터 값을 필요로 할때 마다 이 메서드를 호출하는 모든 부분을 찾아서 수정해야 한다는 문제가 있다. 
  - 데이터를 넘겨주는 객체 자체를 통째로 넘기면 이 문제를 방지할 수 있다.
  - 이렇게 하면 호출된 객체는 넘겨주는 객체로 부터 필요한 것을 무엇이든 요청할 수 있다. 
- 객체를 통째로 전달하는 방식에도 단점은있다. 
  - 값을 전달할 때 호출되는 객체가 그 값들에 의존하게 되지만, 값이 추출된 객체에는 의존하지 않게 된다는 점. 
  - 통 객체를 전달하면 통객체와 호출된 객체가 서로 의존하게 된다. 이것이 의존성 구조를 망가뜨릴 것 같으면 객체를 통째로 전달을 실시하지 말아야한다. 



### 매개변수 세트를 메서드로 전환

- 객체가 A메서드를 호출해서 그 결과를 B메서드에 매개변수로 전달하는데, 결과를 매개변수로 받는 B메서드도 직접 A메서드를 호출 할 수 있을 땐 매개변수를 없애고 A메서드를 B메서드가 호출하게 하자.

- 메서드가 매개변수로 전달 받는 값을 다른 방법으로도 가져올 수 있다면, 그 방법을 택해야 한다. 



### 매개변수 세트를 객체로 전환

- 여러 매개변수가 항상 붙어 다닐 땐 그 매개변수들을 객체로 바꾸자
- 데이터 그룹으로 묶으려면 이 이 매개변수들을 객체로 바꾸는 것이 좋다. 
- 더불어 매개변수를 한 덩이로 만들면 기능을 새 클래스로 옮길 수 있어서 훨씬 좋다. 



### 쓰기 메서드 제거 

- 생성할 때 지정한 필드 값이 절대로 변경되지 말아야할 땐 그 필드를 설정하는 모든 쓰기 메서드를 삭제하자. 
- 쓰기 메서드가 있다는 건 필드 값을 변경할 수 있다는 얘기다.
  - 객체가 생성된 후에는 필드가 변경되지 말아야 한다면, 쓰기 메서드를 작성하지 않아야 한다. 
  - 그렇게 하면 확실히 의도가 달성되고 필드가 수정될 가능성을 차단할 수 있다.