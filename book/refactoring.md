

> 리팩토링을 읽고 정리한 내용입니다. 



# 3. 코드의 구린내

### 중복코드 



### 장황한 메서드

- 이전에는 하위 루틴을 호출할 때 오버헤드 때문에 길게 했으나, 현대 객체 지향에서는 메서드 길이가 길수록 개발자의 머릿속에서 오버헤드가 일어난다. 
- 짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정의해야한다.
- 메서드에 매개변수와 임시변수가 많으면 메서드 추출을 실시하기 어렵다. 
  - 임시 변수를 메서드 호출로 전환 기법
  - 임시 변수를 메서드 체인으로 전환 기법
  - 길게 열거된 매개변수는 매개변수 세트를 객체로 전환 기법
  - 객체를 통째로 전달 기법
  - 메서드 객체로 전환 기법
- 조건문과 루프도 역시 메서드로 빼야 한다. 
  - 조건문 쪼개기 기법
  - 루프를 컬렉션 클로저 메서드로 전환을 실시한 후 그 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시 하면 된다 

### 방대한 클래스

기능이 지나치게 많은 클래스에 엄청난 수의 인스턴스 변수가 들어 있다. (중복코드가 많다 )

- 클래스 추출
- 모듈 추출
- 하위 클래스 추출



### 과다한 매개변수

초보 시절, 필요한 모든 데이터는 매개변수를 사용해 전달하라고 배웠다.

- 객체의 등장으로 상황은 달라짐
- 필요한 데이터가 없을 때는 그것을 가져오도록 다른 객체에 요청하면 된다. 
- 그래서 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는게 아니라 그 모든 데이터를 가져올 메서드만 절달하면 된다. 



이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메서드로 전환 기법을 적용하면 된다. 

### 수정의 산발

- 개발자는 소프트웨어를 수정하기 쉽게 구성한다.
- 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다. 
- 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정도리 때 일어난다. 
  - 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 함. 

### 기능의 산재

- 기능의 산재는 수정의 산발과 비슷하지만 정반대다. 
- 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다. 
  - 메서드 이동과 필드 이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.
- 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때 새 클래스를 만들어야 한다. 
  - 클래스 내용 직접 삽입

- 수정의 산발: 한 클래스에서 여러 수정이 발생하는 문제 
- 기능의 산재: 하나의 수정으로 여러 클래스가 바뀌게 되는 문제

어느 것이든 수정과 클래스가 일대일 대응되게 깔끔하게 정리해야 한다. 

### 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로스세를 한 데 묶는 기술이라는 점이다. 

### 데이터 뭉치

데이터의 항목은 몰려다니는 습성이 있다. 두 클래스에 들어 있는 인스턴스 변수나 여러 메서드에 들어 있는 매개변수처럼, 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 경우가 많다. 이렇게 몰려 있는 데이터 뭉치는 객체로 만들어야 한다. 둘 이상의 필드를 객체로 전화하면 코드가 개선된다.

### 강박적 기본 타입 사용

대개의 프로그랭 환경을 구성하는 데이터는 두 종류다. 하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화 할 수 있다. 기본 타입은 한마디로 초석이라고 할 수 있다. 

### switch 문

객체 지향 코드의 확연한 특징 중 하나는 switch-case 문이 비교적 적게 사용된다는 점이다. switch 문의 단점은 반드시 중복이 생긴다는 점이다. 이를 해결 할 수 있는 최상의 방법은 객체 지향 개념 중 하나인 **<u>다형성, 즉 재정의를 이용하는 것이다.</u>** 

### 평행 상속 계층

한 클래스의 하위클래스를 만들 때 마다 매번 다른 클래스의 하위 클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.

### 직무유기 클래스

하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼 기능을 수행하지 못하는 비효율적인 클래스는 없애야한다. 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 바로 직무유기 클래스에 해당된다. 

### 막연한 범용 코드

### 임시 필드

어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹있다. 이런 떠돌이 변수들이 서식할 집을 마련해 주려면 클래스 추출을 실시해야 한다. 그렇게 작성한 클래스에 그 변수들과 관련된 코드를 전부 넣어야 한다. 

### 메세지 체인

메세지 체인은 클라이언트가 한 객체에 제2의 객체를 요청하면, 제2의 객체가 제 3의 객체를 요청하고, 연쇄적 요청이 발생하는 문제점을 뜻한다. 이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다. 그 상의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다. -> 대리 객체 은폐를 실시해야 한다. 

### 과잉 중개 메서드 

객체의 주요 특징 한가지는 바로 캡슐화다. 캘슐화란 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업을 뜻한다. 캡슐화는 대개 위임이 수반된다. 

### 지나친 관여

간혹 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분을 알아내느라 과도한 시간을 낭비하게 될 때가 있다. 서로 지나치게 관여하는 클래스는 갈라놔야 한다. 

### 인터페이스가 다른 대용 클래스

기능은 같은데 시그니처가 다른 메서드에는 메서드명 변경을 실시해야 한다. 

### 미흡한 라이브러리 클래스

라이브러리 클래스에 넣어야할 메서드가 두개 뿐이라면 외래 클래스에 메서드 추가 기법을 실시하고, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기법을 실시하자. 

### 데이터 클래스

데이터 클래스는 필드와 필드 읽기/쓰 메서드만 들어 있는 클래스다. 그런 클래스는 오로지 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다. 

### 방치된 상속물

하위 클래스는 부모 클래스의 메서드와 데이터를 상속받는다. 그런데 상속받은 메서드나 데이터의 하위클래스에서 더 이상 쓰지 않거나 필요 없을 땐 어떻게 될까? 

1. 잘못된 계층 구조의 문제인 경우, 새 대등 클래스를 작성하고 메서드 하향과 필드 하향 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아 넣어야 한다. 
2. 상속을 위임으로 전환 기법을 적용해서 계층구조를 없애야 한다.



### 불필요한 주석

엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많다. 

어떤 코드 구간의 기능을 설명할 주석이 필요할 때는 메서드 추출을 실시해야 한다. 메서드가 이미 추출된 상태임에도 기능을 설명할 주석이 필요하다면, 메서드명 변경을 실시해야 한다. 시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는 어설션 넣기 





## 테스트 작성





## 6. 메서드 정리

리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다. 

- 핵심적인 리팩토링 기법은 코드 뭉치를 별도의 메서드로 빼내는 **메서드 추출 기법** 
  - 지역변수 처리(임시변수)
    - **메서드 호출로 전환 기법**을 사용해서 임시 변수를 제거한다. 
      - 임시 변수가 여러 부분에 사용 될  때는 **임시 변수 분리**를 실시
    - 임시변수가 너무 얽혀 있어서 메서드 호출로 전환 할 수 없을 때, **메서드 객체로 전환 기법**
- **메서드 내용 직접 삽입**



- 매개변수로 대입하는 값이 있을 때는 **매개변수로의 값 대입 제거**

* 메서드를 잘게 쪼개면 동작 원리를 이해하기가 훨씬 쉽다. 간혹 알고리즘을 명료하게 개선할 수 있음을 알게된다. **알고리즘 전환 기법**





### 메서드 추출

메서드가 너무 길거나 코드의 주석을 달아야만 의도를 이해할 수 있을 때, 그 코드를 빼내어 별도의 메서드로 만든다. 

직관적인 이름이 좋은 이유는 

1. 메서드가 적절히 잘게 쪼개져 있으면 다른 메서드에서 쉽게 사용한다.
2. 상위 계층의 메서드에서 주석 같은 더 많은 정보를 읽어 들일 수 있다.
3. 재정의하기 훨씬 수월하다.

> 중요한 것은 메서드의 길이가 아니라 메서드명과 메서드 내용의 의미적 차이라고 할 수 있다. 메서드 추출로 코드의 명료성이 향상되기만 한다면, 메서드명이 추출한 코드 보다 길어도 메서드 추출을 실시해야 한다.



- 지역변수 문제 중 제일 가벼운 경우는 지역변수가 읽히기만 하고 변경되지 않을 때다. 이럴 땐 지역변수를 매개변수로 전달하면 된다.



### 메서드 내용 직접 삽입

*메서드 기능이 너무 단순해서 메서드명만 봐도 너무 뻔할 땐 그 메서드의 기능을 호출하는 메서드에 넣어버리고 그 메서드는 삭제하자*

### 임시 변수 내용 직접 삽입



### 임시변수를 메서드 호출로 전환

임시변수는 일시적이고 적용이 국소적 범위로 제한된다는 단점이 있다. 임시변수는 자신이 속한 메서드 안에서만 인식되므로, 그 임시변수에 접근하려다 보면 코드는 길어지게 마련이다. 임시변수를 메서드 호출로 수정하면 클래스 안 모든 메서드가 그 정보에 접근 할 수 있다. 이렇게 하면 클래스의 코드가 훨씬 깔끔해 진다. 

해당 경우는 메서드 추출을 적용하기 전에 반드시 적용해야 한다. 지역변수가 많을 수록 메서드 추출이 힘들어지므로 최대한 많은 변수를 메서드 호출로 고쳐야한다. 



#### 예제

```java
double getPrice(){
  int basePrice = _quantity * _itemPrice;
  double discountFaactor;
  
  if (basePrice > 1000){ 
    discountFactor = 0.95
  }else{
    discountFactor = 0.98
  }
 return basePrice * discountFactor;
}
```



```java
double getPrice(){
 return getPrice() * discountFactor();
}

int getPrice(){
   _quantity * _itemPrice
}

double discountFactor(){
  if (getPrice() > 1000){ 
    return 0.95
  }else{
    return = 0.98
  }
 
}
```



### 직관적 임시변수 사용

직관적 임시변수 사용은 조건문에서 각 조건 절을 가져와서 직관적 이름의 임시변수를 사용해 그 조건의 의미를 설명하려 할 때 많이 사용한다. 그 외에 긴 알고리즘에서 임시변수를 사용해서 계산의 각 단계를 설명할 수 있을 때 사용한다. 

**<u>직관적 임시변수 사용 기법을 적용해야겠다는 생각이 들더라도 될 수 있으면 그 기법을 적용하는 것을 자제하고 그 대신 메서드 추출을 사용하려고 노력한다</u>**

임시변수는 하나의 메서드 안에서만 사용할 수 있다. 메서드는 해당 객체의 전역뿐 아니라 다른 객체에도 사용할 수 있다. 

내가 메서드 추출 기법 사용을 선호하는 이유는 그 기법을 실시했을 때 이 메서드들을 객체의 다른 부분에서도 사용할 수 있기 때문이다. 

그럼 도대체 직관적 임시변수 사용 기법은 언제 사용하나? 

당연히 메서드 추출 기법 적용이 더 어렵거나 복잡할 때 사용한다. 알고리즘에 수많은 지역변수가 사용될땐 대체로 메서드 추출을 쉽게 적용할 수 없다. 로직의 복잡함이 덜해지면 나중에 언제든 임시변수를 메서드 호출로 전환 기법을 적용하면 될 일이다. 



### 임시변수 분리

임시변수의 용도는 다양한데, 일부 용도로 사용하다 보면 임시변수에 값이 여러 번 대입될 때가 있다. 여러 용도로 사용되는 변수는 각 용도 별로 다른 변수를 사용하게 분리해야 한다. 



### 매개변수로의 값 대입 제거???

*매개변수로 값을 대입하는 코드가 있을 땐 매개변수 대신 임시변수를 사용하게 수정하자*

매개변수로의 값대입이란? 어떤 메서드에 foo객체를 매개변수로 전달하면 '매개변수로의 값 대입'은 foo의 값을 다른 객체 참조로 변경한다는 의미다. 매개변수로 전달받은 객체에 어떠한 처리를 하든 상관 없고 일상적인 작업이지만, foo의 값을 다른 객체 참조로 변경하는 것은 절대로 안된다. 

```java
void aMethod(Object foo){
  foo.modify(); // 괜찮다.
  foo = anotherObject; // 고통과 절망을 안겨준다. 
}
```

자바에서 매개변수에 값을 대입해서는 안되고, 그런 코드를 보게 된다면 매개변수로의 값대입 제거를 적용해야 한다. 



### 메서드를 메서드 객체로 전환

*지역변수 때문에 메서드 추출을 적용할 수 없는 긴 메서드가 있을때 그 메서드 자체를 객체로 전환해서 모든 지역변수를 객체의 필드로 만들자. 그런 다음 그 메서드를 객체 안의 여러 메서드로 쪼개면 된다.*

이책의 핵심은 간결한 메서드의 아름다움. 장황한 메서드에서 각 부분을 간결한 메서드로 빼내면 코드가 훨씬 이해하기 쉬워진다. 메서드 분해를 어렵게 만드는 건 지역변수다. 

```java
Class Account {
  int gamma (int inputVal, int quantity, int yearToDate){
    int importantValue1 = (inputVal * quantity) + delta();
    int importantValue2 = (inputVal * yearToDate) + 100;
    if ( (yearToDate - importantValue1)> 100 )
      importantValue2 -= 20;
    int importantValue3 = importantValue2 * 7;
    //기타 작업
    return importantValue3 - 2 * importantValue;
  }
}
```



```java
Class Gamma {
  private final Account _account;
  private int inputVal;
  private int quantity;
  private int yearToDate;
  
  Gamma(int inputVal, int quantity, int yearToDate){
    this.inputVal = inputVal;
    this.quantity = quantity;
    this.yearToDate = yearToDate; 
  }
  
  public int compute(){
		int importantValue1 = (inputVal * quantity) + _account.delta();
    int importantValue2 = (inputVal * yearToDate) + 100;

    importantThing(); // 메서드 추출
    int importantValue3 = importantValue2 * 7;
    //기타 작업
    return importantValue3 - 2 * importantValue;
}

  void importantThing(){
    if ( (yearToDate - importantValue1)> 100 )
      importantValue2 -= 20;
  }

Class Account {
  int gamma(int inputVal, int quantity, int yearToDate){
    return new Gamma(inputVal, quantity, yearToDate).compute();
  }
}
```



### 알고리즘 전환

*알고리즘을 더 분명한 것으로 교체해야 할 땐 해당 메서드의 내용을 새 알고리즘으로 바꾸자*

어떤 작업을 약간 다르게 처리해야 해서 알고리즘을 변경해야 할 때도 있는데, 이럴 때는 좀 더 변경하기 쉬운 알고리즘으로 교체하는 것이 간편하다. 이렇게 하려면 메서드를 최대한 잘게 쪼개야 한다. []()



## 7장. 객체간의 기능 이동

### 메서드 이동

*메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 땐, 그 메서드가 제일 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드를 작성하자.*



### 클래스추출(<-> 클래스 추출)

- 두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐, 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자. 

### 

### 대리 객체 은폐(<-> 과잉 중개 메서드 제거)

- 객체의 핵심 개념중 하나는 캡슐화: 객체가 시스템의 다른 부분에 대한 정보의 일부만 알 수 있게 은폐하는 것을 뜻함
  
  - 캡슐화를 통해서 무언가를 변경할때 그 변화를 전달해야 할 객체가 줄어들므로 변경하기 쉬워진다. 
- ### 



### 외래 클래스에 메서드 추가

- 사용중인 서버 클래스에 메서드 추가해야 하는데 그 클래스를 수정할 수 없을 땐 클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성하자. 
- 코드 저작권이 문제라면 외래 메서드를 서버 클래스 제작자에게 보내서 직접 구현해 달라고 요청🐤



#### 국소적 상속확장 클래스 사용

- 사용중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐, 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성하자. 이 상속확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자. 



## 8. 데이터 체계화

- 데이터 연동을 더 간편하게 해준다. 



### 필드 자체 캡슐화

- 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐, 그 필드용 읽기/쓰기 메서드를 작성해서 두 메서드를 통해서만 필드에 접근하게 만들자. 



### 데이터 값을 객체로 전환

- 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만들자. 