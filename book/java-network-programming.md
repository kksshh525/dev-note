>   자바 네트워크 프로그래밍을 읽고 요약한 내용입니다.
>
>   관련 소스코드는 https://github.com/umanking/java-network-programming 



## 3. 스레드 

### Future, callable 그리고 Executor 

-   자바5부터 멀티스레드의 복잡한 내용을 감추고 콜백을 좀더 쉽게 사용할 수 있다. 
-   필요할 때 스레드를 생성, ExecutorService를 제공한다.
-   사용법
    -   작업 대상의 Callable객체를 만들고 ExecutorService에 등록한다. 
    -   등록한 다음 Future객체를 반환받는다. 
    -   나중에 작업 결과를 Future를 통해서 얻는다. 
    -   Future 사용시 이미 결과가 준비되어 있는 경우 즉시 값을 얻지만, 그렇지 않은 경우 폴링 스레드는 준비가 될 때까지 블록된다. 
-   장점?
    -   다양한 종류의 스레드를 생성한 다음, 여러 스레드로부터 원하는 순서대로 값을 얻는다.

### 동기화 

스레드는 도서관에서 책을 비리는 사람과 같다. 스레드는 중앙의 리소스 풀(도서관)로 부터 빌린다. 해당 리소스를 공유하여 프로그램을 효율적으로 만든다. 멀티 스레드의 단점은 두 스레드가 동시에 같은 리소스를 사용한다면 둘 중에 하나는 다른 하나가 리소스 사용을 끝날 때 까지 기다려야한다. 



### 동기화 블록

synchronized를 이용해서 동기화 블록을 설정할 수 있다. 

### 

### 동기화 메서드

메서드에 synchronized 키워드로 동기화 문제를 모두 해결할 수 있는 것은 아니다. 

-   첫째, 심각한 성능 저하 
-   둘째, 데드락이 발생할 가능성이 급격히 높아진다.
-   셋째, 동시 변경이나 접근으로부터 보호하기 위해 항상 객체 자체를 보호해야 하는 것은 아니며, 해당 메서드를 포함한 클래스의 인스턴스를 동기화해도 실제 보호해야 하는 객체를 보호하지 못할 수도 있다. 



### 동기화를 피할 수 있는 방법 

첫째, 필드대신에 가능하면 로컬 변수를 사용하는 것. 메서드 선언시 자바 기본타입을 사용하면 다른 스레드로부터 변경될 위험이 없다. 자바는 인자를 참조가 아닌 값으로 전달하기 때문이다. 

둘째, 여러 분이 만든 클래스에도 이러한 불변성을 이용할 수 있다. 이 방법은 크래스를 스레드로부터 안전하게 만들기 위해 사용할 수 있는 가장 쉬운 방법이며, 어떤 메서드나 코드 영역을 동기화할지 경정하는 것보다 더 쉽다. 

어떤 객체를 불변성을 가지도록 만들려면 객체의 모든 필드를 private 과 final로 선언하고 필드를 변경할 수 있는 어떠한 메서드도 제공하지 않으면된다. 

셋째, 스레드로부터 안전하지 않은 클래스를 스레드로부터 안전한 클래스의 private 필드로만 사용하는 것



### 데드락

동기화로 인해 데드락이 발생할 수 있다. 데드락은 두 스레드가 같은 리소스 집합에 대해서 배타적인 접근이 필요한데, 각 스레드가 해당 리소스의 다른 부분 집합에 이미 배타적인 접근 권한을 가지고 있을 때 발생한다. 이 때 어느 한 스레드도 리소스를 반환하지 않는다면 두 스레드는 영원히 실행이 정지된다.

예를 들면 잭과 질은 각각 토머스 제퍼슨에 관한 학기말 논문을 쓰고 있고, 책1, 책2 두 권이 필요하다. 만약에 잭이 첫번째 책을 빌리고, 질이 두번째 책을 빌리고 둘 중 하나도 책을 반납하지 않는다면, 둘 모두 논문을 작성할 수 없게 된다. 결국 마감일이 지나서 둘 모두 F학점을 받는다. 바로 데드락 문제가 발생한 것이다. 

설상가상으로 가장 드러나지 않는 버그다.

**데드락을 피하기 위한 가장 중요한 기법은 불필요한 동기화를 피하는 것이다.**  객체를 불변으로 구현을 하거나 객체의 로컬 복사본을 만드는 방법과 같은 스레드의 안정성을 보장해 줄 다른 방법이 있다면 사용하는 것이 좋으며, 동기화는 스레드 안정성을 보장해 줄 다른 방법이 있다면 사용하는 것이 좋으며, 동기화는 스레드 안정성을 보장하기 위한 최후의 수단으로 사용해야 한다. 동기화를 꼭 사용해야 한다면 동기화 블록을 최대한 작게 하며, 동시에 하나 이상의 객체에 대해서 동기화하지 않도록 해야 한다. 



### 스레드 스케줄링

다수의 스레드가 동시에 실행될 수 있다면, 스레드 스케줄링에 대해 고민해야 한다. 



### 우선순위 

모든 스레드가 같은 상태로 만들어 지는 것은 아니다. 각 스레드는 0 부터 10까지 정수로된 우선순위를 가진다. 높은 우선순위는 10, 가장 낮은 우선순위는 0이다. (spring 과 우선순위가 반대)

때로는 어떤 스레드에는 다른 스레드보다 더 많은 시간을 할애해야 할 경우가 있다. 사용자와 상호작용하는 스레드가 이에 해당하며, 사용자에게 빠른 응답을 제공할 수 있도록 매우 높은 우선순위를 설정해야 한다. 반면에 백그라운드 연산을 수행하는 스레드에는 낮은 우선순위를 설정할 수 있다. 빨리 끝내야 하는 작업은 높은 우선순위를 설정하고 시간이 많이 걸리는 작업은 우선순위를 낮게 하여 다른 스레드를 방해하지 않도록 해야 한다. 

일반적으로 너무 높은 우선순위의 할당은 우선순위가 낮은 다른 스레드의 기아 상태를 유발할 수 있기 때문에 피해야 한다.



### 선점 

모든 가상 머신은 특정 시점에 실행될 스레드를 결정하는 스레드 스케줄러를 제공한다. 스레드 스케줄링에는 크게 선점형(preemptive) 와 협력형(cooperative) 두 가지가 있다. 선정형 스레드 스케줄러는 스레드에게 공평하게 분배된 CPU시간이 소진되었을 때, 스레드를 중지시키고 다른 스레드에게 CPU제어권을 넘겨주는 일을 결정한다. 협력형 스레드 스케줄러는 CPU제어권을 다른 스레드에게 넘겨주기 전에 실행 중인 스레드가 스스로 실행을 중단할 때 까지 기다린다.

모든 자바 가상 머신은 우선순위에 따른 선점형 스레드 스케줄링 방식의 사용이 보장된다. 즉 높은 우선순위의 스레드를 실행할 준비가 되었을 때 이미 실행 중인 낮은 우선순위의 스레드가 있다면, 가상 머신은 높은 우선순위의 스레드를 실행하기 위해 곧 낮은 우선순위의 스레드를 중지 시키게 된다. 바로 높은 우선순위 스레드가 낮은 우선순위 스레드를 선점한 것이다. 

스레드가 다른 스레드를 위해 실행을 중지하거나 실행을 중지할 준비가 됐음을 알려 주는 다음 10가지 방법

-   I/O블록
-   동기화된 객체에 의한 블록
-   명시적인 양보
-   슬립 상태(sleep)
-   다른 스레드 종료
-   객체 대기(wait)
-   스레드 종료(finish)
-   높은 우선순위 스레드에 의한 선점
-   스레 일시 정지(suspend) - 더 이상 사용하지 X
-   스레드 멈춤(stop) - 더 이상 사용하지 X



#### 블로킹

블로킹은 스레드가 어떤 리소스를 얻기 위해 멈추고 기다려야 하는 상황에 발생한다. 가장 일반적인 상황으로는 네트워크 프로그램의 스레드가 I/O블로킹에 의해 자발적으로 CPU에 대한 제어권을 포기하는 경우가 있다. 

스레드는 또한 동기화된 메서드나 영역에 진입할 때 블록될 수 있다.

I/O에 의한 블로킹이든 락에 의한 블로킹이든 어느 경우에도 블로킹된 스레드는 그 순간 동안 이미 소유하고 있는 어떤 락도 해제할 수 없으며 이로 인해 문제가 발생한다. I/O블록인 경우 시간이 지나면 블록은 결국 해제되고 스레드가 계속해서 실행되거나, IOException이 발생하고 스레드는 동기화된 영역이나 메서드를 빠져나오고 락을 해제하기 때문에 큰 문제가 되지 않는다. 그러나 스레드가 자신이 소유하지 않은 락에 의해서 블로킹된 경우 자신이 이미 소유한 다른 락을 해제하지 못하여 데드락을 유발 시키기도한다. 

#### 양보 

… .. 채우기….





### 스레드 풀과 익스큐터

프로그램에 멀티스레드 구조를 추가하면 극적인 성능 향상을 기대할 수 있다. 입출력이 많은 네트워크 프로그램에 특히 효과가 좋다. 그러나 **스레드 자체에 오버헤드가 없는 것은 아니다. 스레드를 시작하거나 종료된 스레드를 정리하는 작업은 가상 머신에게 적지 않은 부하를 준다. 더욱 중요한 것은 실행중인 스레드 간의 전환 시에도 오버헤드가 발생한다는 것이다.**

java.util.concurrent 안에 있는 **Executors 클래스를 사용하면 스레드 풀**을 쉽게 만들 수 있다. 간단히 수행할 작업을 Runnable 객체로 풀에 등록하기만 하면 작업의 진행 상황을 검사할 수 있는 Future 객체가 반환된다. 



## 4. 인터넷 주소

인터넷에 연결된 장치를 '**노드**'라고 부른다. 노드가 컴퓨터인 경우 해당 노드를 **호스트**라고 부른다. 각 노드나 호스트는 인터넷 주소 또는 IP주소라고 불리는 최소 하나의 고유한 숫자에 의해 식별된다. 

인터넷을 만든 사람들은 전체 IP주소가 적힌 전화번호부 같은 책자를 들고 다니는 일을 피하기 위해 DNS을 개발했다. DNS는 사람들이 쉽게 기억할 수 있는 google.com과 같은 호스트네임을 컴퓨터가 쉽게 기억할 수 있는 ip주소와 연결한다. 



### InetAddress클래스

java.net.InetAddrss클래스는 IPv4, IPv6 주소에 대한 자바의 고수준 표현 방식이다. 이 클래스는 Socket, ServerSocket, URL, DatagramSocket, DatagramPacket등을 포함한 대부분의 다른 네트워킹 클래스에 의해 사용된다. InetAddress 클래스는 보통 호스트네임과 IP주소를 모두를 포함하고 있다. 

### InetAddress 객체 생성하기



#### 캐시

DNS검색(lookup)은 최종 쿼리 서버에 도착하기 까지 여러 중간 단계의 서버를 거쳐야 하고 종종 중간에 손실되는 경우도 있기 때문에 상대적으로 비용이 많이 드는 명령에 해당한다. 그래서 InetAddress 클래스는 검색의 결과를 저장(cache)한다. 

#### IP주소로 검색하기 

호스트네임을 사용하는 것이 IP를 직접 사용하는 것보다 좀 더 안정적이다. 

#### 보안 이슈 

호스트 네임으로부터 새로운 InetAddress 객체를 생성하는 일은 DNS검색을 필요로 하기 때문에 잠재적인 보안 문제에 노출되어 있다. 



### Get메서드 

InetAddress 클래스는 호스트네임을 문자열로 반환하고 IP주소를 문자열과 바이트 배열로 반환하는 네 개의 Get메서드를 제공한다. 

```java
public String getHostName()
public String getCanonicalHostName()
public byte[] getAddress()
public String getHostAddress()
```



```java
public class OreillyByName {
    public static void main(String[] args){
        InetAddress inetAddress = null;
        try {
            inetAddress = InetAddress.getByName("www.oreilly.com");

            System.out.println("hostAddress : " +inetAddress.getHostAddress());
            System.out.println("canonicalHostName : "+ inetAddress.getCanonicalHostName());
            System.out.println("hostName: "+ inetAddress.getHostName());
            System.out.println("address : "+ Arrays.toString(inetAddress.getAddress()));
            
        } catch (UnknownHostException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

```
hostAddress : 23.76.90.240
canonicalHostName : a23-76-90-240.deploy.static.akamaitechnologies.com
hostName: www.oreilly.com
address : [23, 76, 90, -16]
```



