



## 쓰레드 동기화 

-   멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업의 영향을 준다. 
-   이러한 일을 방지하기 위해서 한 쓰레드가 특정 작업을 끝마치기 전에 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 
    -   도입된 개념이 바로 '임계영역(critical section)'과 잠금(lock)이다. 
-   한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 **쓰레드의 동기화** 라 한다.



### 9.1 synchronized를 이용한 동기화 

```java
	// 1. 메서드 전체 임계영역 지정
	public synchronized void sum(){
    	//..임계영역
	}

	// 2. 특정 영역을 지정
	synchronized(객체의 참조변수){
        
    }
```

첫번째 방법은 메서드 앞에 `synchronized`를 붙이고, 메서드 전체가 임계영역으로 설정된다. 쓰레드는 synchronized 메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메서드가 종료되면 락을 반환한다.

두번째 방법은 메서드내의 코드 일부를 블럭 {} 으로 감싸고 블럭앞에 synchronized 키워드를 붙인다. 이 때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 이 블럭 영역 안에 들어가면 쓰레드는 지정된 객체의 락을 얻고, 이블럭을 벗어나면 락을 반납한다. 

두 가지 방법은 락 획득 반납을 자동으로 해주기 때문에 우리가 할 일은 그저 임계영역만을 설정해 주는 것 뿐이다.



### 9.2 wait()과 notify()

synchronized로 동기화 해서 공유 데이터를 보호하는 것 까지는 좋다. 하지만 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것이 중요하다. 이런 상황을 개선하기 위해서 고안된 것이 wait()와 notify()이다. 

**동기화된 임계영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 wait()를 호출하여 쓰레드가 락을 반납하고 기다리게 한다.**

그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게 된다. 나중에 작업을 진행할 수 있는 상황이 되면 **notify()를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.** 





### 9.3 Lock과 Condition을 이용한 동기화 

동기화 할 수 있는 방법은 synchronized블럭 외에도 `java.util.concurrent.locks` 패키지가 제공하는 lock클래스들을 이용하는 방법이 있다. jdk1.5부터 추가됨

synchronized 블록으로 동기화 하면 자동으로 락이 잠기고, 풀리기 때문에 편리하다. 심지어 예외가 발생해도 락이 자동으로 풀린다. **그러나 때로 같은 메서드 내에서만 lock을 걸 수 있다는  제약이 불편하다.** 그럴 때 lock클래스를 사용한다.

-   ReentrantLock : 재진입 가능한 락, 가장 일반적인 배타 lock
-   ReentrantReadWriteLock: 읽기에는 공유적이고, 쓰기에는 배타적인 lock
-   StampedLock: ReentrantReadWriteLock에 낙관적인 lock 기능을 추가



