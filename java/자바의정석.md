



## 쓰레드 동기화 

-   멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업의 영향을 준다. 
-   이러한 일을 방지하기 위해서 한 쓰레드가 특정 작업을 끝마치기 전에 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 
    -   도입된 개념이 바로 '임계영역(critical section)'과 잠금(lock)이다. 
-   한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 **쓰레드의 동기화** 라 한다.



### 9.1 synchronized를 이용한 동기화 

```java
	// 1. 메서드 전체 임계영역 지정
	public synchronized void sum(){
    	//..임계영역
	}

	// 2. 특정 영역을 지정
	synchronized(객체의 참조변수){
        
    }
```

첫번째 방법은 메서드 앞에 `synchronized`를 붙이고, 메서드 전체가 임계영역으로 설정된다. 쓰레드는 synchronized 메서드가 **호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메서드가 종료되면 락을 반환**한다.

두번째 방법은 메서드내의 코드 일부를 블럭 {} 으로 감싸고 블럭앞에 synchronized 키워드를 붙인다. 이 때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. **이 블럭 영역 안에 들어가면 쓰레드는 지정된 객체의 락을 얻고, 이블럭을 벗어나면 락을 반납한다.** 

두 가지 방법은 락 획득 반납을 자동으로 해주기 때문에 우리가 할 일은 그저 임계영역만을 설정해 주는 것 뿐이다.



### 9.2 wait()과 notify()

synchronized로 동기화 해서 공유 데이터를 보호하는 것 까지는 좋다. 하지만 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것이 중요하다. 이런 상황을 개선하기 위해서 고안된 것이 wait()와 notify()이다. 

**동기화된 임계영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, 일단 wait()를 호출하여 쓰레드가 락을 반납하고 기다리게 한다.**

그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게 된다. 나중에 작업을 진행할 수 있는 상황이 되면 **notify()를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.** 





### 9.3 Lock과 Condition을 이용한 동기화 

동기화 할 수 있는 방법은 synchronized블럭 외에도 `java.util.concurrent.locks` 패키지가 제공하는 lock클래스들을 이용하는 방법이 있다. jdk1.5부터 추가됨

synchronized 블록으로 동기화 하면 자동으로 락이 잠기고, 풀리기 때문에 편리하다. 심지어 예외가 발생해도 락이 자동으로 풀린다. **그러나 때로 같은 메서드 내에서만 lock을 걸 수 있다는  제약이 불편하다.** 그럴 때 lock클래스를 사용한다.

-   ReentrantLock : 재진입 가능한 락, 가장 일반적인 배타 lock
-   ReentrantReadWriteLock: 읽기에는 공유적이고, 쓰기에는 배타적인 lock
-   StampedLock: ReentrantReadWriteLock에 낙관적인 lock 기능을 추가



ReentrantLock은 가장 일반적인 락이다. 'reentrant(재진입할 수 있는)'이라는 단어가 앞에 붙은 이유는 앞에서 살펴본 wait() & notify()에서 배운 것 처럼, 특정 조건에서 락을 풀고 나중에 다시 락을 얻고 임계영역으로 들어와서 이후의 작업을 수행할 수 있다. 

ReentrantReadWriteLock은 읽기를 위한 락과 쓰기를 위한 락을 제공한다. ReentrantLock은 배타적인 락이라서 무조건 락이 있어야만 임계영역의 코드를 수행할 수 있지만, ReentrantReadWriteLock은 읽기 락이 걸려 있으면, 다른 쓰레드가 읽기 락을 중복해서 걸고 읽기를 수행할 수 있다. 읽기는 내용을 변경하지 않기 때문에 동시에 여러 쓰레드가 읽어도 문제가 되지 않는다. 그러나 읽기 락에서 쓰기락을 거는 것은 허용되지 않는다. 반대의 경우도 마찬가지다.

StamptedLock은 락을 걸거나 해지할때 '스탬프(long타입의 정수값)'을 사용하며, 읽기와 쓰기를 위한 락이외에 '낙관적인 락'이 추가된 것이다. 읽기 락이 걸려있으면, 쓰기 락을 얻기 위해서는 읽기 락이 풀릴때 까지 기다려야 하는데 비해 '낙관적인 읽기 락'은 쓰기 락에 의해 바로 풀린다. 그래서 낙관적인 읽기에 실패하면, 읽기 락을 얻어서 다시 읽어 와야 한다. **무조건 읽기 락을 걸지 않고, 쓰기와 읽기가 충돌할때만 쓰기가 끝난 후에 읽기 락을 거는 것이다.** 



#### ReentrantLock 생성자 

```java
ReentrantLock()
ReentrantLock(boolean fair)
```

생성자 매개변수 true주면, 락이 풀렸을때 가장 오래 기다린 쓰레드가 락을 획득할 수 있게 공정하게 처리한다. 가장 오래 기다린 쓰레드를 확인하는 과정을 거치기 때문에 성능은 떨어진다. 대부분 공정하게 처리하지 않아도 되므로 공정함 보다는 성능을 선택한다. 

```java
void lock() // 락을 잠근다
void unlock() // 락을 해지한다.
boolean isLocked() //락이 잠겼는지 확인한다.
```

자동적으로 락의 잠금과 해제가 관리되는 synchronized 블럭과 달리, ReentrantLock과 같은 락클래스들은 수동으로 락을 잠그고 해제해야 한다. 

임계영역 내에서 예외가 발생하거나 return문으로 빠져나가게 되면 락이 풀리지 않을 수 있으므로 unlock()은 try-finally문으로 감싸는 것이 일반적이다. 

```java
lock.lock(); 
try {
    // 임계영역
}finally{
    lock.unlock();
}
```

이렇게 하면 try블럭 내에 어떤 일이 발생해도 finally블럭에 있는 unlock()이 수행되어 락이 풀리지 않는 일은 발생하지 않는다.

이외에도 tryLock()이라는 메서드가 있는데 이 메서드는 lock()과 달리, 다른 쓰레드에 의해 락이 걸려있으면 락을 얻으려고 기다리지 않는다. 또는 지정된 시간만큼만 기다린다. 락을 얻으면 true, 얻지 못하면 false를 반환한다. 

```java
boolean tryLock()
boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException
```

lock()은 락을 얻을 때 까지 쓰레드를 블락 시키므로 쓰레드 응답성이 나빠질 수 있다. 응답성이 중요한 경우, tryLock()을 이용해서 지정된 시간동안 락을 얻지 못하면 다시 작업을 시도할 것인지 포기할 것인지를 사용자가 결정할 수 있게 하는 것이 좋다. 또한 이 메서드는 InterruptedException을 발생시킬수 있는데 이것은 지정된 시간동안 락을 얻으려고 기다리는 중에 interrupt()에 의해 작업을 취소 될 수 있도록 코드를 작성할 수 있다는 뜻이다. 



### 9.4 volatile

멀티 코어 프로세서에서는 코어마다 별도의 캐시를 가지고 있다. 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다. 다시 같은 값을 읽어 올 때는 먼저 캐시에 있는지 확인하고 없을때만 메모리에서 읽어온다. 그러다 보니 도중에 메모리에 저장된 변수의 값이 변경되었는데도 캐시에 저장된 값이 갱신되지 않아서 메모리에 저장된 값이 다른 경우가 발생한다.

**<u>그러나 변수 앞에volatile을 붙이면, 코어가 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오기 때문에 캐시와 메모리간의 값의 불일치를 해결된다.</u>**

변수에 volatile을 붙이는 대신에 synchronized블럭을 사용해도 같은 효과를 얻을 수 있다. 쓰레드가 synchronized블럭으로 들어갈 때와 나올때 캐시와 메모리간의 동기화가 이루어지기 때문에 값의 불일치가 해소되기 때문이다. 

#### volatile로 long과 double을 원자화 

JVM은 데이터를 4byte단위로 처리하기 때문에 int와 int보다 작은 타입들은 한 번에 읽거나 쓰는 것이 가능하다. 즉, 단 하나의 명령어로 읽거나 쓰기가 가능하다는 뜻이다. 하나의 명령어는 더 이상 나눌 수 없는 최소의 작업단위로, 작업의 중간에 다른 쓰레드가 끼어들 틈이 없다.

그러나 크기가 8byte인 long과 double타입의 변수는 하나의 명령어로 값을 읽거나 쓸 수 없기 때문에 변수의 값을 읽는 과정에 다른 쓰레드가 끼어들 여지가 있다. 변수를 읽고 쓰는 모든 문장을 synchronized블럭으로 감쌀 수도 있지만, 더 간단한 방법은 변수를 선언할 때 volatile을 붙이는 것이다. volatile은 해당 변수에 대한 읽거나 쓰기가 원자화된다.

```java
volatile long sharedVal; // long타입의 변수 (8byte)를 원자화
volatile double sharedVal2; // double 타입의 변수 (8byte)를 원자화
```

volatile은 변수를 읽거나 쓰기를 원자화할 뿐, 동기화 하는 것은 아니라는 점에 주의하자. 



